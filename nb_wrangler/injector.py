from pathlib import Path
import shutil
import re

from .logger import WranglerLogger
from .repository import RepositoryManager
from .spec_manager import SpecManager
from . import utils


def get_injector(
    logger: WranglerLogger, repo_manager: RepositoryManager, spec_manager: SpecManager
) -> "SpiInjector":
    """
    Factory method to create a subclass of a Injector which is tuned to
    configure an science-platform-images deployment based on a wrangler spec.

    Conceptually another subclass of Injector could be created to inject into
    a different image building system.
    """
    return SpiInjector(logger, repo_manager, spec_manager)


class SpiInjector:
    """
    A class for interacting with a Science Platform Images (SPI) respository,
    which includes finding extra package requirements for the curated environment
    and also updating the repository deployment with the final package requirements
    generated by the spec.
    """

    _url = "https://github.com/spacetelescope/science-platform-images.git"

    def __init__(
        self,
        logger: WranglerLogger,
        repo_manager: RepositoryManager,
        spec_manager: SpecManager,
    ):
        self.logger = logger
        self.repo_manager = repo_manager
        self.spec_manager = spec_manager
        self.spi_path = Path(repo_manager.repos_dir) / self.repo_name
        self.deployment_name = self.spec_manager.deployment_name
        self.kernel_name = self.spec_manager.kernel_name
        self.base_ingest_branch = "origin/main"
        self.ingest_dir = Path("nbw-spec-archive")
        self.archive_dir = Path("nbw-spec-archive")
        self.deployments_path = self.spi_path / "deployments"
        self.deployment_path = self.deployments_path / self.deployment_name
        self.environments_path = self.deployment_path / "environments"
        self.kernel_path = self.environments_path / self.kernel_name
        self.test_path = self.kernel_path / "tests"
        self.env_pip = self.kernel_path / f"{self.kernel_name}.pip"
        self.env_yml = self.kernel_path / f"{self.kernel_name}.yml"
        self.pip_patterns = [
            self.deployments_path / "common/common-env/*.pip",
            self.kernel_path / "*.pip",
        ]
        self.mamba_patterns = [
            self.deployments_path / "common/common-env/*.conda",
            self.kernel_path / "*.conda",
            self.deployments_path / "common/common-env/*.mamba",
            self.kernel_path / "*.mamba",
        ]

    @property
    def url(self):
        return self.spec_manager.spi_url or self._url

    @property
    def repo_name(self):
        name = self.url.split("/")[-1]
        return name.split(".")[0]

    @property
    def spec_id(self):
        return self.spec_manager.sha256[:6]

    @property
    def core_name(self):
        """Core name for both submission branch and archived spec,  minus file extension."

        Designed to sort repo spec archive simply into time order with the latest spec last
        and also to be directly traceable to the contents of the spec it names. This enables
        verifying that the image built and tagged corresponds to the submission.

        Based on: submission/current time, sanitized image name, prefix of spec sha256.
        """
        # Replace spaces, dots, etc. with "-".  Preserve case.
        ingestified = re.sub("[^0-9a-zA-Z-]", "-", self.spec_manager.image_name)
        return "-".join(["nbw", utils.hex_time(), ingestified, self.spec_id])

    @property
    def ingest_branch(self):
        """Name of branch that will be PR'ed for this submission."""
        return self.core_name

    @property
    def ingest_name(self) -> str:
        """Name of spec when added to wrangler nbw-spec-archive directory, traceable to both
        ingest branch, image tag, and PR.
        """
        return self.core_name + ".yaml"

    def submit_for_build(self):
        title = f"Wrangler spec for build {self.ingest_name}."
        message = f"""
Added wrangler spec {self.ingest_name} for {self.spec_manager.deployment_name}.
Hash: {self.spec_manager.sha256}
Description:
{self.spec_manager.description}
        """
        if not self.add_to_ingest(
            self.base_ingest_branch, self.ingest_name, self.ingest_branch, message
        ):
            return False
        if not self.push_and_pr(
            self.base_ingest_branch, self.ingest_branch, title, message
        ):
            return False
        return self.logger.info("Spec submission complete.")

    def add_to_ingest(
        self,
        base_ingest_branch: str,
        ingest_name: str,
        new_ingest_branch: str,
        message: str,
    ) -> bool | str:
        """During GitHub actions, copy the spec from the ingest directory
        to an archive location with a more recognizable name.
        """
        self.logger.info(
            f"Adding spec {ingest_name} to ingest directory {self.ingest_dir} on branch {new_ingest_branch}."
        )
        if not self.repo_manager.branch_repo(
            self.repo_name, new_ingest_branch, base_ingest_branch
        ):
            return False
        spec_dest = self.spi_path / self.ingest_dir
        spec_dest.mkdir(exist_ok=True, parents=True)
        self.copy_file(self.spec_manager.spec_file, spec_dest / ingest_name)
        if not self.repo_manager.git_add(self.repo_name, self.ingest_dir / ingest_name):
            return False
        if not self.repo_manager.git_commit(self.repo_name, message):
            return False
        return True

    def copy_file(self, fromfile: Path | str, tofile: Path | str) -> bool:
        fromfile, tofile = str(fromfile), str(tofile)
        self.logger.debug(f"Copying {fromfile} to {tofile}.")
        shutil.copy(fromfile, tofile)
        return True

    def push_and_pr(
        self, base_ingest_branch: str, new_ingest_branch: str, title: str, message: str
    ):
        self.logger.info(f"Pushing submission branch {new_ingest_branch}....")
        if not self.repo_manager.git_push(self.repo_name, new_ingest_branch):
            return False
        self.logger.info("Creating PR...")
        if not self.repo_manager.github_create_pr(
            self.repo_name, base_ingest_branch, title, message
        ):
            return False
        return True

    def set_wrangler_spec(self) -> bool:
        """Write out the wrangler environment spec with a generic name."""
        out_spec = self.environments_path / "nb-wrangler-spec.yaml"
        self.logger.info("Saving spec to SPI environments dir: ", out_spec)
        return self.spec_manager.save_spec(out_spec)

    def inject(self) -> bool:
        """
        Performs a placeholder injection of the SPI.
        In a real implementation, this would gather information about
        the Python environment, installed packages, Jupyter kernels, etc.
        """
        self.logger.info(
            f"Initiating SPI injection into {self.spi_path} for {self.deployment_name} kernel {self.kernel_name}..."
        )
        self._inject("notebook_repo_urls", self.environments_path / "notebook-repos")
        self._inject("mamba_spec", self.env_yml)
        self._inject("pip_compiler_output", self.env_pip)
        self._inject("test_imports", self.test_path / "imports")
        self._inject("test_notebooks", self.test_path / "notebooks")
        self.spec_manager.save_spec_as(
            self.environments_path / "nbw-wrangler-spec.yaml", add_sha256=True
        )
        return self.logger.info("SPI injection complete.")

    def _inject(self, field: str, where: str | Path) -> None:
        self.logger.info(f"Injecting field {field} to {where}")
        with open(str(where), "w") as f:
            obj = self.spec_manager.get_output_data(field)
            if isinstance(obj, dict):
                utils.get_yaml().dump(obj, f)
            elif isinstance(obj, list):
                f.write("\n".join(obj))
            elif isinstance(obj, str):
                f.write(obj)
            else:
                raise ValueError(f"Unsupported type {type(obj)} for field {field}")

    def get_spi_requirements(
        self, glob_patterns: list[Path], kind: str, extraneous: Path
    ) -> list[Path]:
        """Find extra mamba or pip requirements files required by SPI environments such as those
        included in the common/common-env directory. mamba packages are typically non-Python packages
        such as C libraries and compiles and install tools.  For Python packages,  using
        pip to install them is preferred.
        """
        temp = extraneous.open().read()
        extraneous.unlink(missing_ok=True)
        spi_extra_requirements = []
        for pattern in glob_patterns:
            extras = Path(".").glob(str(pattern))
            for path in extras:
                spi_extra_requirements.append(path)
                self.logger.debug(
                    f"Found SPI {kind} requirements file {path} based on glob '{pattern}'"
                )
        self.logger.info(
            f"Found SPI extra {len(spi_extra_requirements)} {kind} requirements files."
        )
        extraneous.open("w+").write(temp)
        return spi_extra_requirements

    def find_spi_pip_files(self) -> list[Path]:
        return self.get_spi_requirements(self.pip_patterns, "pip", self.env_pip)

    def find_spi_mamba_files(self) -> list[Path]:
        return self.get_spi_requirements(self.mamba_patterns, "mamba", self.env_yml)
